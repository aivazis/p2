// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_journal_Diagnostic_icc)
#error this file contains implementation details for pyre::journal::Diagnostic
#else


// metamethods
template <typename severityT>
pyre::journal::Diagnostic<severityT>::
Diagnostic() :
    _entry(),
    _buffer(),
    _metadata()
{}


// interface
// accessors
template <typename severityT>
auto
pyre::journal::Diagnostic<severityT>::
buffer() -> string_type
{
    // easy enough
    return _buffer.str();
}


template <typename severityT>
auto
pyre::journal::Diagnostic<severityT>::
entry() const -> const entry_type &
{
    // easy enough
    return _entry;
}


// conversion to an {ostream} so that standard manipulators work as expected
template <typename severityT>
pyre::journal::Diagnostic<severityT>::
operator ostream_type & ()
{
    // grant access to my buffer
    return _buffer;
}


// end of transaction
template <typename severityT>
auto
pyre::journal::Diagnostic<severityT>::
record() -> Diagnostic<severityT> &
{
    // flush the {buffer}
    newline();

    // me as a {severity_type}; this works trivially because of crtp
    severity_type & self = static_cast<severity_type &>(*this);
    // write the journal entry to the device
    self.commit();

    // clean up
    _entry.clear();
    _metadata.clear();

    // all done
    return self;
}


// new line
template <typename severityT>
auto
pyre::journal::Diagnostic<severityT>::
newline() -> Diagnostic<severityT> &
{
    // add the contents of the buffer to the message page
    _entry.push_back(_buffer.str());
    // clear out the buffer contents
    _buffer.str(string_type());
    // reset any error flags
    _buffer.clear();
    // all done
    return *this;
}


// metadata decoration
template <typename severityT>
auto
pyre::journal::Diagnostic<severityT>::
setattr(const key_type & key, const value_type & value) -> Diagnostic<severityT> &
{
    // record the metadata
    _metadata[key] = value;
    // all done
    return *this;
}


// item injection
template <typename severityT>
template <typename itemT>
auto
pyre::journal::Diagnostic<severityT>::
inject(const itemT & item) -> Diagnostic &
{
    // inject into my buffer
    _buffer << item;
    // all done
    return *this;
}


// manipulators
// end of transaction
template <typename severityT>
auto
pyre::journal::
endl(Diagnostic<severityT> & channel) -> Diagnostic<severityT> &
{
    // ask the channel to record the accumulated message
    return channel.record();
}


template <typename severityT>
auto
pyre::journal::
newline(Diagnostic<severityT> & channel) -> Diagnostic<severityT> &
{
    // ask the channel to mark the end of a line of output
    return channel.newline();
}


// the injection operators
// location info
template <typename severityT>
auto
pyre::journal::
operator<< (Diagnostic<severityT> & channel, const Locator & locator) -> Diagnostic<severityT> &
{
    // use the locator information to set channel metadata
    channel.setattr("filename", locator.file());
    channel.setattr("line", locator.line());
    channel.setattr("function", locator.func());

    // all done
    return channel;
}


// metadata
template <typename severityT>
auto
pyre::journal::
operator<< (Diagnostic<severityT> & channel, const Selector & selector) -> Diagnostic<severityT> &
{
    // transfer the selector metadata
    channel.setattr(selector.key(), selector.value());

    // all done
    return channel;
}


// injection of manipulator functions
template <typename severityT>
inline auto
pyre::journal::
operator<< (Diagnostic<severityT> & channel,
            Diagnostic<severityT> & (*manipulator)(Diagnostic<severityT> &))
    -> Diagnostic<severityT> &
{
    // invoke the manipulator function with the {channel} as an argument
    return manipulator(channel);
}


// injection of everything else
template <typename severityT, typename itemT>
auto
pyre::journal::
operator<< (Diagnostic<severityT> & channel, const itemT & item) -> Diagnostic<severityT> &
{
    // inject the item in the channel and return the channel
    return channel.inject(item);
}


#endif

// end of file
