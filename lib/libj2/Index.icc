// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_journal_Index_icc)
#error this file contains implementation details for pyre::journal::Index
#else


// metamethods
#if 0
template <typename inventoryT>
pyre::journal::Index<inventoryT>::
Index() :
    _index()
{}
#endif


// interface
template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
size() const
{
    return _index.size();
}


template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
empty() const
{
    return _index.empty();
}


template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
contains(const name_type & channel) const -> bool
{
    // attempt to locate the {channel}
    auto place = _index.find(channel);
    // if i can't find it
    if (place == _index.end()) {
        // i don't have it
        return false;
    }
    // otherwise, i do
    return true;
}


template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
begin() const
{
    return _index.begin();
}


template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
end() const
{
    return _index.end();
}


template <typename inventoryT>
auto
pyre::journal::Index<inventoryT>::
lookup(const name_type & channel) -> inventory_type &
{
    // attempt to locate the {channel} state
    auto place = _index.find(channel);
    // if it's there
    if (place != _index.end()) {
        // grab it
        auto & inventory = place->second;
        // we are done
        return inventory;
    }

    // if the channel name is not in the index, we will make a new inventory and insert it; the
    // only question is what should the state of this new inventory be. we support a cascading
    // mechanism: treating the character '.' as a separator to form a hierarchy, a channel
    // inherits the state of its nearest ancestor. if no ancestor exists, the inventory is
    // initialized in its default state

    // if we fail to find an ancestor, initialize the inventory state with the default value
    inventory_type inventory;
    // use a period as the separator
    auto separator = '.';
    // initialize the end of the search for the separator; initially, look through the entire
    // string
    auto stop = name_type::npos;
    // until we manage to get out of this loop
    while (1) {
        // locate the last occurrence of the separator
        auto pos = channel.find_last_of(separator, stop);
        // if not there
        if (pos == name_type::npos) {
            // nothing else to do
            break;
        }
        // otherwise, extract the fragment up to the separator
        auto fragment = channel.substr(0, pos);
        // attempt to look it up in the index
        auto place = _index.find(fragment);
        // if it's there
        if (place != _index.end()) {
            // grab it
            inventory = place->second;
            // and get out of here
            break;
        }
        // otherwise, adjust the stopping place and look again
        stop = pos - 1;
    }

    // use the harvested state to initialize the channel inventory
    auto status = _index.emplace(channel, inventory);
    // if this failed
    if (status.second == false) {
        // something terrible has happened
        throw std::runtime_error("unable to emplace channel inventory");
    }
    // access the newly built shared state
    auto & shared = status.first->second;
    // and return it
    return shared;
}


template <typename inventoryT>
void
pyre::journal::Index<inventoryT>::
insert(const name_type & channel, const inventory_type & inventory)
{
    // place the inventory in the map
    _index[channel] = inventory;
    // all done
    return;
}


#endif

// end of file
