// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_grid_Canonical_icc)
#error this file contains implementation details for pyre::grid::Canonical
#else


// metamethods
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr
pyre::grid::Canonical<N, containerT>::
Canonical(shape_type shape, index_type origin, order_type order) :
    _shape { shape },
    _order { order },
    _origin { origin },
    _strides { strides(shape, order) },
    _nudge { project(_origin, _strides) }
{}


// interface
// accessors for the user supplied information
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
shape() const -> shape_type
{
    // easy enough
    return _shape;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
order() const -> order_type
{
    // easy enough
    return _order;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
origin() const -> index_type
{
    // easy enough
    return _origin;
}


// accessors for the deduced information
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
strides() const -> strides_type
{
    // easy enough
    return _strides;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
nudge() const -> difference_type
{
    // easy enough
    return _nudge;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
capacity() const -> size_type
{
    // my {shape} knows
    return _shape.capacity();
}


// mutators
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
order(const order_type & order) const -> canonical_type
{
    // make a new packing using my info and the supplied {order}
    canonical_type reordered { _shape, _origin, order };
    // and return it
    return reordered;
}


// from {difference_type} to {index_type}
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
index(difference_type offset) const -> index_type
{
    // make an empty index
    index_type index;
    // get the capacity of the layout
    auto product = this->capacity();

    // get my shape
    auto shape = this->shape();
    // and my index packing order
    auto order = this->order();

    // loop in reverse packing order
    for (size_t axis = this->dim(); axis > 0; --axis) {
        // pull the extent of the current axis out of the layout capacity
        product /= shape[order[axis-1]];
        // set the index value
        index[order[axis-1]] = offset / product;
        // adjust
        offset %= product;
    }

    // shift it by the {origin} and return it
    return index + this->origin();
}


// from {index_type} to {difference_type}
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
offset(const index_type & index) const -> difference_type
{
    // initialize the offset
    difference_type offset = 0;
    // and the running product of the shape factors
    size_type product = 1;

    // get my shape
    auto shape = this->shape();
    // and my packing order
    auto order = this->order();

    // in packing order
    for (auto axis : order) {
        // update the offset
        offset += index[axis] * product;
        // update the product
        product *= shape[axis];
    }

    // shift the result by the fixed offset of the {origin} and return it
    return offset - _nudge;
}


// iteration support
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
begin() const -> index_iterator
{
    // make an iterator that generates index in my packing {order}, starting at my {origin}
    return index_iterator(shape(), order(), origin());
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
end() const -> index_iterator
{
    // build the end of the container: start at the origin
    auto end = _origin;
    // and for every rank
    for (auto rank : _order) {
        // add my shape
        end[rank] += _shape[rank];
    }
    // build an iterator that points to the end
    return index_iterator(_shape, _order, end);
}


// static interface
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::dim() -> size_type
{
    // easy enough
    return N;
}


// static helpers
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::strides(const shape_type & shape,
                                  const order_type & order) -> strides_type
{
    // make an empty shape to store the answer
    strides_type strides;

    // initialize the running product
    size_type product = 1;
    // go through indices in order
    for (auto axis : order) {
        // store the running product as the stride of the current axis
        strides[axis] = product;
        // and update it
        product *= shape[axis];
    }

    // all done
    return strides;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::project(const index_type & index,
                                  const strides_type & strides) -> difference_type
{
    // the initial value; here so we can be explicit about the return type
    difference_type init = 0;
    // project and return
    return std::inner_product(index.begin(), index.end(), strides.begin(), init);
}


#endif

// end of file
