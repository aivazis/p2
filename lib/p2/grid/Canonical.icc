// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_grid_Canonical_icc)
#error this file contains implementation details for pyre::grid::Canonical
#else


// metamethods
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr
pyre::grid::Canonical<N, containerT>::
Canonical(shape_type shape, index_type origin, order_type order) :
    _shape { shape },
    _order { order },
    _origin { origin },
    _strides { strides(shape, order) },
    _nudge { project(_origin, _strides) }
{}


// interface
// accessors for the user supplied information
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
shape() const -> shape_type
{
    // easy enough
    return _shape;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
order() const -> order_type
{
    // easy enough
    return _order;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
origin() const -> index_type
{
    // easy enough
    return _origin;
}


// accessors for the deduced information
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
strides() const -> strides_type
{
    // easy enough
    return _strides;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
nudge() const -> difference_type
{
    // easy enough
    return _nudge;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
capacity() const -> size_type
{
    // my {shape} knows
    return _shape.capacity();
}


// from {difference_type} to {index_type}
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
index(difference_type offset) -> index_type
{
    // make an empty index
    index_type index;
    // get the capacity of the layout
    auto product = this->capacity();

    // get my shape
    auto shape = this->shape();
    // and my index packing order
    auto order = this->order();

    // loop in reverse packing order
    for (size_t axis = this->dim(); axis > 0; --axis) {
        // pull the extent of the current axis out of the layout capacity
        product /= shape[order[axis-1]];
        // set the index value
        index[order[axis-1]] = offset / product;
        // adjust
        offset %= product;
    }

    // shift it by the {origin} and return it
    return index + this->origin();
}


// from {index_type} to {difference_type}
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::
offset(const index_type & index) -> difference_type
{
    // initialize the offset
    difference_type offset = 0;
    // and the running product of the shape factors
    typename shape_type::axis_type product = 1;

    // get my shape
    auto shape = this->shape();
    // and my packing order
    auto order = this->order();

    // in packing order
    for (auto axis : order) {
        // update the offset
        offset += index[axis] * product;
        // update the product
        product *= shape[axis];
    }

    // shift the result by the fixed offset of the {origin} and return it
    return offset - _nudge;
}


// static interface
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::dim() -> size_type
{
    return N;
}


// static helpers
template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::strides(const shape_type & shape,
                                  const order_type & order) -> strides_type
{
    // make an empty shape to store the answer
    strides_type strides;

    // initialize the running product
    typename shape_type::axis_type product = 1;
    // go through indices in order
    for (auto axis : order) {
        // store the running product as the stride of the current axis
        strides[axis] = product;
        // and update it
        product *= shape[axis];
    }

    // all done
    return strides;
}


template <pyre::grid::size_t N, template <typename, size_t> class containerT>
constexpr auto
pyre::grid::Canonical<N, containerT>::project(const index_type & index,
                                  const strides_type & strides) -> difference_type
{
    // the initial value; here so we can be explicit about the return type
    difference_type init = 0;
    // project and return
    return std::inner_product(index.begin(), index.end(), strides.begin(), init);
}


#endif

// end of file
