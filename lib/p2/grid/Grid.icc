// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved


// code guard
#if !defined(pyre_grid_Grid_icc)
#error this file contains implementation details for pyre::grid::Grid
#else


// metamethods
template <class packingT, class storageT>
constexpr
pyre::grid::Grid<packingT, storageT>::
Grid(packing_const_reference layout, storage_pointer data) :
    _data { data },
    _layout { layout }
{}


// accessors
template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
data() const -> storage_pointer
{
    // easy enough
    return _data;
}


template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
layout() const -> packing_const_reference
{
    // easy enough
    return _layout;
}


// data access
template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
operator[](index_const_reference index) -> reference
{
    // get the offset that corresponds to this {index}
    auto offset = _layout[index];
    // get and return the value
    return (*_data)[offset];
}


template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
operator[](index_const_reference index) const -> const_reference
{
    // get the offset that corresponds to this {index}
    auto offset = _layout[index];
    // get and return the value
    return (*_data)[offset];
}


// iteration support
template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
begin() const
{
    // delegate to my layout
    return _layout.begin();
}


template <class packingT, class storageT>
constexpr auto
pyre::grid::Grid<packingT, storageT>::
end() const
{
    // delegate to my layout
    return _layout.end();
}


#endif

// end of file
