// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_grid_Order_icc)
#error this file contains implementation details for pyre::grid::Order
#else


// metamethods
template <size_t N, template <typename, size_t> typename containerT>
template <typename... argT>
constexpr
pyre::grid::Order<N, containerT>::
Order(argT... args) :
    rep_type( args... )
{}


// static interface: factories
// column major oder
template <size_t N, template <typename, size_t> typename containerT>
constexpr auto
pyre::grid::Order<N, containerT>::
columnMajor() -> order_type
{
    // declare the helper argument: an empty object, used only for its type
    auto arg = std::make_index_sequence<N> {};
    // invoke the helper
    return _columnMajor(arg);
}


// alias for the above
template <size_t N, template <typename, size_t> typename containerT>
constexpr auto
pyre::grid::Order<N, containerT>::
fortran() -> order_type
{
    // delegate
    return columnMajor();
}


// row major oder
template <size_t N, template <typename, size_t> typename containerT>
constexpr auto
pyre::grid::Order<N, containerT>::
rowMajor() -> order_type
{
    // declare the helper argument: an empty object, used only for its type
    auto arg = std::make_index_sequence<N> {};
    // invoke the helper
    return _rowMajor(arg);
}


// alias for the above
template <size_t N, template <typename, size_t> typename containerT>
constexpr auto
pyre::grid::Order<N, containerT>::
c() -> order_type
{
    // delegate
    return rowMajor();
}


// operators
// stream injection
template <pyre::grid::size_t N, template <typename, pyre::grid::size_t> class containerT>
auto
pyre::grid::
operator<< (ostream_t & stream, const Order<N, containerT> & ord) -> ostream_reference
{
    // make an alias for the {order_t}
    using order_t = Order<N, containerT>;

    // the renderer
    auto fold = [](string_t partial, typename order_t::rank_type value) {
                    return std::move(partial) + ", " + std::to_string(value);
                };
    // fold the index values into a string
    string_t rep = std::accumulate(std::next(ord.begin()),
                                   ord.end(),
                                   std::to_string(ord[0]),
                                   fold);
    // inject the representation
    stream << rep;
    // and return
    return stream;
}


// implementation details
// column major helper
template <pyre::grid::size_t N, template <typename, pyre::grid::size_t> class containerT>
template<pyre::grid::size_t... seq>
constexpr auto
pyre::grid::Order<N, containerT>::
_columnMajor(std::index_sequence<seq...>) -> order_type
{
    // enforce our invariant
    static_assert( N == sizeof...(seq) );
    // aggregate initialize my return value with the sequence [0, ..., N-1]
    // don't forget that the constructor is marked {explicit} so we need to say what we mean
    return order_type { seq... };
}


template <pyre::grid::size_t N, template <typename, pyre::grid::size_t> class containerT>
template<pyre::grid::size_t... seq>
constexpr auto
pyre::grid::Order<N, containerT>::
_rowMajor(std::index_sequence<seq...>) -> order_type
{
    // enforce our invariant
    static_assert( N == sizeof...(seq) );
    // aggregate initialize my return value with the sequence [N-1, ..., 0]
    // don't forget that the constructor is marked {explicit} so we need to say what we mean
    return order_type { sizeof...(seq) - 1 - seq... };
}


#endif

// end of file
