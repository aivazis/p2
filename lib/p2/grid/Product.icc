// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved

// code guard
#if !defined(pyre_grid_Product_icc)
#error this file contains implementation details for pyre::grid::Product
#else

// metamethods
template <pyre::grid::size_t N, typename factorT>
template <typename... argT>
constexpr pyre::grid::Product<N, factorT>::Product(argT... idx) :
    _rep { static_cast<factor_type>(idx)... }
{}


// interface
// read only
template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::operator[](size_type pos) const -> factor_type
{
    return _rep[pos];
}

// read/write
template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::operator[](size_type factor) -> factor_reference
{
    return _rep[factor];
}


// iteration support
// read only
template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::begin() const
{
    return _rep.cbegin();
}

template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::end() const
{
    return _rep.cend();
}


// read/write
template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::begin()
{
    return _rep.begin();
}

template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::end()
{
    return _rep.end();
}


// static interface
template <pyre::grid::size_t N, typename factorT>
constexpr auto
pyre::grid::Product<N, factorT>::dim() -> size_type
{
    return N;
}


// operators
// equality
template <pyre::grid::size_t N, typename factorT>
constexpr bool
pyre::grid::
operator== (const Product<N, factorT> & p1, const Product<N, factorT> & p2)
{
    // delegate to the standard algorithm
    return std::equal(p1.begin(), p1.end(), p2.begin());
}


// and not
template <pyre::grid::size_t N, typename factorT>
constexpr bool
pyre::grid::
operator!= (const Product<N, factorT> & p1, const Product<N, factorT> & p2)
{
    // delegate to {operator==}
    return !(p1 == p2);
}


// stream injection
template <pyre::grid::size_t N, typename factorT>
auto
pyre::grid::
operator<< (ostream_t & stream, const Product<N, factorT> & p) -> ostream_reference
{
    // the renderer
    auto fold = [](string_t partial, typename Product<N, factorT>::factor_type value) {
                    return std::move(partial) + ", " + std::to_string(value);
                };
    // fold the index values into a string
    string_t rep = std::accumulate(std::next(p.begin()),
                                   p.end(),
                                   std::to_string(p[0]),
                                   fold);
    // inject the representation
    stream << rep;
    // and return
    return stream;
}



#endif

// end of file
