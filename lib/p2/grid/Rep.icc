// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved


// code guard
#if !defined(pyre_grid_Rep_icc)
#error this file contains implementation details for pyre::grid::Rep
#else


// metamethods
template <class containerT>
template <typename... argT>
constexpr
pyre::grid::Rep<containerT>::
Rep(argT... args) :
    _rep { static_cast<value_type>(args)... }
{}


// access with bounds checking
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
at(size_type pos) -> reference
{
    // delegate to my rep
    return _rep.at(pos);
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
at(size_type pos) const -> const_reference
{
    // delegate to my rep
    return _rep.at(pos);
}


// random access
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
operator[](size_type pos) -> reference
{
    // delegate to my rep
    return _rep[pos];
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
operator[](size_type pos) const -> const_reference
{
    // delegate to my rep
    return _rep[pos];
}


// iteration
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
begin() -> iterator
{
    // delegate to my rep
    return _rep.begin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
begin() const -> const_iterator
{
    // delegate to my rep
    return _rep.begin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
end() -> iterator
{
    // delegate to my rep
    return _rep.end();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
end() const -> const_iterator
{
    // delegate to my rep
    return _rep.end();
}


// reverse iteration
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
rbegin() -> reverse_iterator
{
    // delegate to my rep
    return _rep.begin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
rbegin() const -> const_reverse_iterator
{
    // delegate to my rep
    return _rep.rbegin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
rend() -> reverse_iterator
{
    // delegate to my rep
    return _rep.rend();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
rend() const -> const_reverse_iterator
{
    // delegate to my rep
    return _rep.rend();
}


// const iteration
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
cbegin() const -> const_iterator
{
    // delegate to my rep
    return _rep.cbegin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
cend() const -> const_iterator
{
    // delegate to my rep
    return _rep.cend();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
crbegin() const -> const_reverse_iterator
{
    // delegate to my rep
    return _rep.crbegin();
}


template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
crend() const -> const_reverse_iterator
{
    // delegate to my rep
    return _rep.crend();
}


// static interface
// get the rank of the rep
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
rank() -> size_type
{
    // the rank is equal to the number of slots in the rep
    return std::tuple_size<container_type>::value;
}


// make a rep and fill it with zeroes
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
zero() -> rep_type
{
    // make one with an empty initializer; the language guarantees zero initialization
    return rep_type {};
}


// make a rep and fill it with ones
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
one() -> rep_type
{
    // make one
    rep_type rep {};
    // fill it
    std::fill(rep.begin(), rep.end(), 1);
    // and return it
    return rep;
}


// fill with a spcific value
template <class containerT>
constexpr auto
pyre::grid::Rep<containerT>::
fill(const_reference value) -> rep_type
{
    // make one
    rep_type rep {};
    // fill it
    std::fill(rep.begin(), rep.end(), value);
    // and return it
    return rep;
}


// operators
// equality
template <class containerT>
constexpr auto
pyre::grid::
operator== (const Rep<containerT> & rep1, const Rep<containerT> & rep2) -> bool
{
    // let the STL handle it
    // this would be the preferred way
    // return std::equal(rep1.begin(), rep1.end(), rep2.begin());
    // but {std::equal} is not {constexpr} until {c++20};,in the meantime
    for (auto i1 = rep1.begin(), i2 = rep2.begin(); i1 != rep1.end(); ++i1, ++i2) {
        // if there is a mismatch at the current location
        if (*i1 != *i2) {
            // all done
            return false;
        }
    }
    // if we get this far
    return true;
}


// inequality
template <class containerT>
constexpr auto
pyre::grid::
operator!= (const Rep<containerT> & rep1, const Rep<containerT> & rep2) -> bool
{
    return !(rep1 == rep2);
}


// injection operator
template <class containerT>
auto
pyre::grid::
operator<< (ostream_reference stream, const Rep<containerT> & rep) -> ostream_reference
{
    // make an alias for {rep}
    using rep_t = Rep<containerT>;

    // the renderer
    auto fold = [](string_t partial, typename rep_t::value_type value) {
                    return std::move(partial) + ", " + std::to_string(value);
                };
    // fold the index values into a string
    string_t text = std::accumulate(std::next(rep.begin()),
                                    rep.end(),
                                    std::to_string(rep.at(0)),
                                    fold);
    // inject the representation
    stream << text;
    // all done
    return stream;
}


// arithmetic
template <class containerT>
constexpr auto
pyre::grid::
operator+ (const Rep<containerT> & i1, const Rep<containerT> & i2) -> Rep<containerT>
{
    // make a default index
    Rep<containerT> sum;

    // go through each axis
    for (size_t axis = 0; axis < sum.rank(); ++axis) {
        // do the math
        sum[axis] = i1[axis] + i2[axis];
    }

    // all done
    return sum;
}


template <class containerT>
constexpr auto
pyre::grid::
operator- (const Rep<containerT> & i1, const Rep<containerT> & i2) -> Rep<containerT>
{
    // make a default index
    Rep<containerT> diff;

    // go through each axis
    for (size_t axis = 0; axis < diff.rank(); ++axis) {
        // do the math
        diff[axis] = i1[axis] - i2[axis];
    }

    // all done
    return diff;
}


// scaling by integers
template <class containerT>
constexpr auto
pyre::grid::
operator* (const Rep<containerT> & i, int s) -> Rep<containerT>
{
    // make a default index
    Rep<containerT> scaled;

    // go through each axis
    for (size_t axis = 0; axis < scaled.rank(); ++axis) {
        // do the math
        scaled[axis] = s * i[axis];
    }

    // all done
    return scaled;
}


template <class containerT>
constexpr auto
pyre::grid::
operator* (int s, const Rep<containerT> & i) -> Rep<containerT>
{
    // easy
    return i * s;
}


template <class containerT>
constexpr auto
pyre::grid::
operator/ (const Rep<containerT> & i, int s) -> Rep<containerT>
{
    // make a default index
    Rep<containerT> scaled;

    // go through each axis
    for (size_t axis = 0; axis < scaled.rank(); ++axis) {
        // do the math
        scaled[axis] = i[axis] / s;
    }

    // all done
    return scaled;
}


#endif

// end of file
