// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved


// code guard
#if !defined(pyre_memory_Heap_icc)
#error this file contains implementation details for pyre::memory::Heap
#else


// metamethods
// destructor
template <class T, bool checkBounds>
pyre::memory::Heap<T, checkBounds>::
~Heap()
{
    // deallocate my block
    delete [] _data;
}


// constructor
template <class T, bool checkBounds>
pyre::memory::Heap<T, checkBounds>::
Heap(cell_count_type cells) :
    _data{ new value_type[cells] },
    _cells{ cells }
{}


// interface
// get the number of cells in the block
template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
cells() const
{
    // easy
    return _cells;
}


// get the memory footprint of the block
template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
bytes() const
{
    // scale the number of cells by the cell size
    return cells() * sizeof(value_type);
}


// access to the data pointer
template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
data() const
{
    // return the raw data pointer
    return _data;
}


// iterator support
template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
begin() -> pointer
{
    // the beginning of the block
    return data();
}


template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
end() -> pointer
{
    // one past the last cell in the block
    return data() + cells();
}


// data access
template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
operator [] (size_type pos) -> reference
{
    // if we are checking bounds
    if (checkBounds && pos >= cells()) {
        // make a channel
        pyre::journal::firewall_t channel("pyre.memory.bounds");
        // and complain
        channel
            << "out of bounds access:" << pyre::journal::newline
            << "  index " << pos << " must be less than " << cells() << pyre::journal::newline
            << "  in pyre::memory::heap_t::operator[]" << pyre::journal::newline
            << "  with a block on the heap at " << data()
            << pyre::journal::endl(__HERE__);
        // unreachable, unless the user has marked this error as non-fatal
        // clamp {pos} to the last element in the block
        pos = cells() - 1;
    }

    // return a reference to the cell at {pos}
    return _data[pos];
}


template <class T, bool checkBounds>
auto
pyre::memory::Heap<T, checkBounds>::
operator [] (size_type pos) const -> const_reference
{
    // if we are checking bounds
    if (checkBounds && pos >= cells()) {
        // make a channel
        pyre::journal::firewall_t channel("pyre.memory.bounds");
        // and complain
        channel
            << "out of bounds access:" << pyre::journal::newline
            << "  index " << pos << " must be less than " << cells() << pyre::journal::newline
            << "  in pyre::memory::heap_t::operator[]" << pyre::journal::newline
            << "  with a block on the heap at " << data()
            << pyre::journal::endl(__HERE__);
        // unreachable, unless the user has marked this error as non-fatal
        // clamp {pos} to the last element in the block
        pos = cells() - 1;
    }

    // return a reference to the cell at {pos}
    return _data[pos];
}


#endif

// end of file
