// -*- c++ -*-
//
// michael a.g. aïvázis <michael.aivazis@para-sim.com>
// (c) 1998-2020 all rights reserved


// code guard
#if !defined(pyre_memory_Map_icc)
#error this file contains implementation details for pyre::memory::Map
#else


// map over an existing data product
template <typename T, bool checkBounds>
pyre::memory::Map<T, checkBounds>::
Map(uri_type uri, writable_type writable) :
    FileMap(uri, writable)
{}


// create a new one
template <typename T, bool checkBounds>
pyre::memory::Map<T, checkBounds>::
Map(uri_type uri, size_type cells) :
    // scale up the number of cells to the number of bytes
    FileMap(uri, cells * sizeof(value_type))
{}


// interface
// compute the number of cells in the memory block
template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
cells() const
{
    // convert using my size in bytes
    return bytes() / sizeof(value_type);
}


// access to the raw data pointer
template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
data() const
{
    // cast my data pointer to a {pointer}
    return static_cast<pointer>(FileMap::data());
}


// iterator support
// iterator start
template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
begin() -> pointer
{
    // return the beginning of the block
    return data();
}


// iterator end
template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
end() -> pointer
{
    // return one past the end of the block
    return data() + cells();
}


// array-like access
template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
operator [] (size_type pos) -> reference
{
    // check the arguments
    if (checkBounds && pos >= cells()) {
        // make a channel
        pyre::journal::firewall_t channel("pyre.memory.bounds");
        // complain
        channel
            << "out of bounds access:" << pyre::journal::newline
            << "  index " << pos << " must be less than " << cells() << pyre::journal::newline
            << "  in pyre::memory::Map::operator[]" << pyre::journal::newline
            << "  with a map over " << uri()
            << pyre::journal::endl(__HERE__);
        // unreachable, unless the user has marked this error as non-fatal
        // clamp {pos} to the last element in the block
        pos = cells() - 1;
    }
    // get the cell and return it
    return data()[pos];
}


template <typename T, bool checkBounds>
auto
pyre::memory::Map<T, checkBounds>::
operator [] (size_type pos) const -> const_reference
{
    // check the arguments
    if (checkBounds && pos >= cells()) {
        // make a channel
        pyre::journal::firewall_t channel("pyre.memory.bounds");
        // complain
        channel
            << "out of bounds access:" << pyre::journal::newline
            << "  index " << pos << " must be less than " << cells() << pyre::journal::newline
            << "  in pyre::memory::Map::operator[]" << pyre::journal::newline
            << "  with a map over " << uri()
            << pyre::journal::endl(__HERE__);
        // unreachable, unless the user has marked this error as non-fatal
        // clamp {pos} to the last element in the block
        pos = cells() - 1;
    }

    // get the cell and return it
    return data()[pos];
}


#endif

// end of file
